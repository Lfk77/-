

**鲁付康 22121998**

## 实验内容

### 1、用孩子兄弟表示法表示树

#### 1.1 定义结点

```c++
template <class ElemType>
struct TreeNode 
{
// 数据成员:
	ElemType data;								
	TreeNode<ElemType> *firstChild;	
	TreeNode<ElemType> *nextSibling;
// 构造函数:
	TreeNode();						// 无参数的构造函数
	TreeNode(ElemType val,			// 有参数的构造函数
		TreeNode<ElemType> *fChild = NULL,
		TreeNode<ElemType> *nSibling = NULL);		
};
template<class ElemType>
TreeNode<ElemType>::TreeNode()
{
	firstChild = nextSibling = NULL;
}
template<class ElemType>
TreeNode<ElemType>::TreeNode(ElemType val,
		TreeNode<ElemType> *fChild,
		TreeNode<ElemType> *nSibling)
{
	data = val;				
	firstChild = fChild;
	nextSibling = nSibling;	
}

```



#### 1.2 函数声明

``` c++
template <class ElemType>
class Tree
{
protected:
	//  树的数据成员:
	TreeNode<ElemType> *root; // 根指针
	//	辅助函数:
	void Destroy(TreeNode<ElemType> *&r);	 // 销毁以r为根的树
	int Height(TreeNode<ElemType> *r) const; // 求以r为根的树的高
	int Degree(TreeNode<ElemType> *r) const; // 求以r为根的树的度
	TreeNode<ElemType> *CopyTree(TreeNode<ElemType> *copy);// 复制树
	TreeNode<ElemType> *CreateTreeGhelp(ElemType items[], int parents[], int r, int n);
    // 由双亲表示法构造树，并返回树的根
public:
	//  声明:
	Tree();								 // 无参数的构造函数
	virtual ~Tree();					 // 析构函数
	TreeNode<ElemType> *GetRoot() const; //  求树的根
	bool IsEmpty() const;				 // 判断树是否为空
	int Degree() const;					 // 求树的度
	int Height() const;					 //  求树的高
	Tree(const Tree<ElemType> &copy);	 // 复制构造函数
	Tree(ElemType items[], int parents[], int n);// 由双亲表示法构造树
	Tree(TreeNode<ElemType> *r); // 建立以r为根的树
	Tree<ElemType> &operator=(const Tree<ElemType> &copy);// 重载赋值运算
};
template <class ElemType>
void DisplayTWithConcaveShape(const Tree<ElemType> &t, TreeNode<ElemType> *r, int level);
// 显示树，level为层次数，设根结点的层次数为1
template <class ElemType>
void DisplayTWithConcaveShape(const Tree<ElemType> &t);// 显示树
template <class ElemType>
void CreateTree(TreeNode<ElemType> *&r, ElemType pre[], ElemType in[],
				int preLeft, int preRight, int inLeft, int inRight);
// 已知树的先根序列和后根序列构造以r为根的树
template <class ElemType>
Tree<ElemType> &CreateTree(ElemType pre[], ElemType in[], int n);
// 已知先根和后根序列构造树
```



#### 1.3 函数实现

* (1)无参数的构造函数

  ``` c++
  template <class ElemType>
  Tree<ElemType>::Tree()
  // 构造一个空树
  {
  	root = NULL; // 表示树为空
  }
  ```

  

* (2)析构函数

  借助功能为销毁以r为根的树的辅助函数Destroy(TreeNode<ElemType> *&r)完成

  ``` c++
  template <class ElemType>
  void Tree<ElemType>::Destroy(TreeNode<ElemType> *&r)
  // 销毁以r为根的树
  {
  	TreeNode<ElemType> *p;
  	if (r != NULL)
  	{
  		for (p = r->firstChild; p != NULL; p = p->nextSibling)
  			Destroy(p); // 销毁子树
  		delete r;		// 销毁根结点
  		r = NULL;
  	}
  }
  template <class ElemType>
  Tree<ElemType>::~Tree()
  // 析造函数
  {
  	Destroy(root);
  }
  ```

  

* (3)求树的根

  ``` c++
  template <class ElemType>
  TreeNode<ElemType> *Tree<ElemType>::GetRoot() const
  // 求树的根
  {
  	return root;
  }
  ```

  

* (4)判断树是否为空

  ```c++
  template <class ElemType>
  bool Tree<ElemType>::IsEmpty() const
  // 判断树是否为空
  {
  	return root == NULL;
  }
  ```

  

* (5)建立以r为根的树

  ```c++
  template <class ElemType>
  Tree<ElemType>::Tree(TreeNode<ElemType> *r)
  // 建立以r为根的树
  {
  	root = r;
  }
  ```

  

* (6)复制构造函数

  借助功能为将以troot为根的树复制成新的树, 求新树的根的辅助函数CopyTree(TreeNode<ElemType> *troot)来实现。

  具体实现过程如下：

  1. 如果输入的根节点`troot`为空，则直接返回空指针，表示新树也为空。
  2. 如果`troot`不为空，则开始复制非空二叉树。
  3. 首先创建一个新的根节点`r`，其数据值为`troot`的数据值，表示新树的根节点。
  4. 接着，利用递归的方式复制`troot`的每一个子树。对于每个子树，都递归调用`CopyTree`函数，将子树复制，并返回新的子树的根节点。
  5. 在复制子树的过程中，将每个复制得到的子树连接到新树中。如果是新树的第一个子树，则直接将其作为新树的首孩子，否则将其连接到新树中的上一个子树的后面（作为兄弟节点）。

  在每次递归调用中，都会遍历`troot`的子节点，并对每个子节点进行复制，因此时间复杂度取决于树的节点数量。假设树的节点总数为n，则在最坏情况下，每个节点都要复制一次，所以时间复杂度为O(n)。

  ``` c++
  template <class ElemType>
  TreeNode<ElemType> *Tree<ElemType>::CopyTree(TreeNode<ElemType> *troot)
  // 将以troot为根的树复制成新的树, 求新树的根
  {
  	if (troot == NULL)
  		return NULL; // 空二叉树根为空
  	else
  	{																 // 复制非空二叉树
  		TreeNode<ElemType> *r = new TreeNode<ElemType>(troot->data); // 复制根结点
  		TreeNode<ElemType> *subTreeRoot, *cur, *p;
  		for (p = troot->firstChild; p != NULL; p = p->nextSibling)
  		{							   // 复制子树
  			subTreeRoot = CopyTree(p); // 复制子树
  			if (r->firstChild == NULL)
  			{
  				r->firstChild = subTreeRoot; // subTreeRoot为首孩子
  				cur = subTreeRoot;			 // cur最新复制的子树的根
  			}
  			else
  			{
  				cur->nextSibling = subTreeRoot; // subTreeRoot为下一个兄弟
  				cur = subTreeRoot;				// cur最新复制的子树的根
  			}
  		}
  		return r;
  	}
  }
  template <class ElemType>
  Tree<ElemType>::Tree(const Tree<ElemType> &t)
  // 由已知树构造新树——复制构造函数
  {
  	root = CopyTree(t.GetRoot());
  }
  ```

  

* (7)重载赋值运算

  ``` c++
  template <class ElemType>
  Tree<ElemType> &Tree<ElemType>::operator=(const Tree<ElemType> &copy)
  // 由已知树copy复制到当前树--赋值运算重载
  {
  	if (&copy != this)
  	{
  		Destroy(root); // 销毁树
  		root = CopyTree(copy.GetRoot());
  	}
  	return *this;
  }
  ```

  

* (8)已知树的先根序列和后根序列构造以r为根的树

  由于树的先根序列和后根序列分别对应二叉树的先序序列和中序序列，所以可以通过树的先根序列和后根序列按二叉树的模式构造树

  具体实现过程如下：

  1. `CreateTree` 函数是一个递归函数，用于构造以 `r` 为根节点的树。首先检查中根序列的范围，如果范围不合法（即 `inLeft > inRight`），则表示当前子树为空，将根节点 `r` 置为 `NULL`。
  2. 如果范围合法，则根据先根序列的第一个元素创建根节点 `r`。
  3. 然后，在中根序列中找到根节点的位置 `mid`，这个位置将左右子树分开。
  4. 递归调用 `CreateTree` 函数来构造左子树和右子树。对于左子树，先根序列的范围是 `[preLeft + 1, preLeft + mid - inLeft]`，中根序列的范围是 `[inLeft, mid - 1]`；对于右子树，先根序列的范围是 `[preLeft + mid - inLeft + 1, preRight]`，中根序列的范围是 `[mid + 1, inRight]`。
  5. 最后，递归结束后，根据递归的结果，构造了以 `r` 为根节点的树。

  在每次递归调用中，都需要线性查找中根序列中根节点的位置 `mid`，因此时间复杂度取决于中根序列的大小 `n`。假设中根序列的大小为 `n`，则在每次递归中最坏情况下需要遍历 `n` 个元素，因此时间复杂度为 `O(n)`。整体上，由于递归调用的次数与树的高度相关，因此构造树的时间复杂度与树的高度成正比。

  ``` c++
  template <class ElemType>
  void CreateTree(TreeNode<ElemType> *&r, ElemType pre[], ElemType in[],
  				int preLeft, int preRight, int inLeft, int inRight)
  // 已知树的先根序列和后根序列构造以r为根的树
  {
  	if (inLeft > inRight) // 树无结点,空树
  		r = NULL;		  // 树根为空
  	else
  	{											  // 树有结点,非空树
  		r = new TreeNode<ElemType>(pre[preLeft]); // 生成根结点
  		int mid = inLeft;
  		while (in[mid] != pre[preLeft])
  			mid++;
  		CreateTree(r->firstChild, pre, in, preLeft + 1, preLeft + mid - inLeft, inLeft, mid - 1);
  		// 生成左子树
  		CreateTree(r->nextSibling, pre, in, preLeft + mid - inLeft + 1, preRight, mid + 1,
  				   inRight); // 生成右子树
  	}
  }
  
  template <class ElemType>
  Tree<ElemType> &CreateTree(ElemType pre[], ElemType in[], int n)
  // 已知先根和后根序列构造树
  {
  	TreeNode<ElemType> *r; // 树的根
  	CreateTree<ElemType>(r, pre, in, 0, n - 1, 0, n - 1);
  	// 由先根和后根序列构造以r为根的树
  	Tree<ElemType> *bt = new Tree<ElemType>(r); // 生成树
  	return *bt;
  }
  ```

  

* (9)由双亲表示法构造树

  具体实现过程如下：

  1. 首先，检查输入的根节点索引 `r` 是否合法，即在 `0` 到 `n-1` 的范围内，其中 `n` 是元素数组的大小。
  2. 如果 `r` 合法，则创建一个新的根节点 `rt`，其数据值为 `elems[r]`，表示根节点的值。
  3. 然后，遍历整个父节点数组 `parents[]`，查找所有的孩子节点，即父节点为 `r` 的节点。
  4. 对于每个找到的孩子节点，递归调用 `CreateTreeGhelp` 函数来建立以该孩子节点为根的子树，并将其连接到根节点的子节点列表中。
  5. 如果根节点的第一个子节点为空，则将当前子树根节点连接为根节点的第一个子节点，否则将其连接为上一个子节点的兄弟节点。
  6. 最后返回根节点 `rt`。

  在每次递归调用中，都需要遍历整个父节点数组，因此时间复杂度取决于父节点数组的大小 `n`。假设父节点数组的大小为 `n`，则最坏情况下需要遍历 `n` 个元素，因此时间复杂度为 `O(n)`。

  ``` c++
  template <class ElemType>
  TreeNode<ElemType> *Tree<ElemType>::CreateTreeGhelp(ElemType elems[], int parents[], int r, int n)
  // 由双亲表示法构造树，并返回树的根
  {
  	if (r >= 0 && r < n)
  	{
  		TreeNode<ElemType> *rt = new TreeNode<ElemType>(elems[r]); // 复制根结点
  		TreeNode<ElemType> *subTreeRoot, *cur;
  		for (int i = 0; i < n; i++)
  		{ // 查找r的孩子
  			if (parents[i] == r)
  			{ // 建立以pos为根的子树
  				subTreeRoot = CreateTreeGhelp(elems, parents, i, n);
  				if (rt->firstChild == NULL)
  				{ // subTreeRoot为rt第一棵子树的根
  					rt->firstChild = subTreeRoot;
  					cur = subTreeRoot; // cur最新复制的子树的根
  				}
  				else
  				{ // subTreeRoot为cur的下一个兄弟
  					cur->nextSibling = subTreeRoot;
  					cur = subTreeRoot;
  				}
  			}
  		}
  		return rt;
  	}
  	else
  		return NULL; // r非法，建立空树
  }
  template <class ElemType>
  Tree<ElemType>::Tree(ElemType elems[], int parents[], int n)
  // 由双亲表示法构造树
  {
  	root = CreateTreeGhelp(elems, parents, 0, n);
  }
  ```
  
  
  
* (10)显示树

  具体实现过程如下：

  1. `DisplayTWithConcaveShape` 函数是一个递归函数，用于显示以 `r` 为根节点的树。函数接受三个参数：`t` 是树对象的引用，`r` 是当前处理的根节点，`level` 是当前节点的层次数。
  2. 首先，检查当前根节点 `r` 是否为空，如果为空则直接返回。
  3. 如果根节点不为空，则在新行上显示该节点，并确保该节点在其所在层次的列上对齐显示。具体做法是在当前层次之前输出一定数量的空格，以保证在第 `level` 列上显示节点。
  4. 然后，遍历当前节点的所有子节点，并对每个子节点递归调用 `DisplayTWithConcaveShape` 函数，层次数增加 1，以显示该子树。
  5. 主接口函数 `DisplayTWithConcaveShape` 接受一个树对象 `t` 作为参数，并调用辅助函数 `DisplayTWithConcaveShape` 来显示整棵树。它首先获取树的根节点，然后以层次数为 1 调用辅助函数，从根节点开始递归显示整棵树。
  6. 最后，在显示完整棵树后，换行结束。

  对于每个节点，都需要打印该节点的数据，并递归地处理其子节点，因此时间复杂度与树的节点数量成正比，即为 `O(n)`，其中 `n` 是树的节点数量。

  ``` c++
  template <class ElemType>
  void DisplayTWithConcaveShape(const Tree<ElemType> &t,
  							  TreeNode<ElemType> *r, int level)
  // 显示树，level为层次数，设根结点的层次数为1
  {
  	TreeNode<ElemType> *p;
  	if (r != NULL)
  	{
  		cout << endl; // 显示新行
  		for (int i = 0; i < level - 1; i++)
  			cout << "  "; // 确保在第level列显示结点
  		ElemType e;
  		cout << r->data; // 显示结点元素值
  		for (p = r->firstChild; p != NULL; p = p->nextSibling)
  			DisplayTWithConcaveShape(t, p, level + 1); // 依次显示各棵子树
  	}
  }
  
  template <class ElemType>
  void DisplayTWithConcaveShape(const Tree<ElemType> &t)
  // 显示树
  {
  	DisplayTWithConcaveShape(t, t.GetRoot(), 1); // 调用辅助函数显示树
  	cout << endl;								 // 换行
  }
  ```

  

#### 1.4 结果测试

采用了两种方法构造树，分别是双亲法和先根后根序列，其结果在第二个内容中一起展示。

### 2、求树的高和度

#### 2.1 函数实现

* 求树高

  具体实现过程如下：

  1. 首先，检查当前根节点 `r` 是否为空。如果为空，则表示树的高度为0，直接返回0。
  2. 如果根节点不为空，则初始化一个变量 `maxHeight` 用于记录子树的最大高度，并设置一个变量 `h` 用于存储当前子树的高度。
  3. 遍历当前节点的所有子节点，并对每个子节点递归调用 `Height` 函数，求得各子树的高度。
  4. 在遍历过程中，不断更新 `maxHeight` 变量，记录最大的子树高度。
  5. 最后，返回 `maxHeight + 1`，即为当前树的高度，因为树的高度等于各子树高度的最大值再加1。

  该函数的时间复杂度主要取决于树的节点数量，因为在每个节点处都需要遍历其所有子节点，并递归调用 `Height` 函数。因此，时间复杂度为 `O(n)`，其中 `n` 是树的节点数量。

  ``` c++
  template <class ElemType>
  int Tree<ElemType>::Height(TreeNode<ElemType> *r) const
  // 求以r为根的树的高
  {
  	TreeNode<ElemType> *p;
  	if (r == NULL)
  		return 0;
  	else
  	{
  		int maxHeight = 0, h;
  		for (p = r->firstChild; p != NULL; p = p->nextSibling)
  		{
  			h = Height(p); // 求各子树的高
  			if (h > maxHeight)
  				maxHeight = h; // 求各子树高的最大值
  		}
  		return maxHeight + 1; // 树高为各子树的最大值再加1
  	}
  }
  
  template <class ElemType>
  int Tree<ElemType>::Height() const
  // 求树的高
  {
  	return Height(root);
  }
  ```

* 求树度

  具体实现过程如下：

  1. `Degree` 函数是一个递归函数，用于求以给定节点 `r` 为根的树的度。函数首先初始化一个变量 `d` 用于记录当前节点的度（即其子节点数），以及一个变量 `maxDegree` 用于记录子树的最大度。
  2. 遍历当前节点的所有子节点，并对每个子节点递归调用 `Degree` 函数，求得各子树的度。在遍历过程中，不断更新 `d` 变量，记录当前节点的度，并更新 `maxDegree` 变量，记录子树的最大度。
  3. 最后，返回 `maxDegree`，即为以当前节点 `r` 为根的树的度。

  对于每个节点，都需要遍历其所有子节点，并递归调用 `Degree` 函数，因此时间复杂度取决于树的节点数量。在最坏情况下，每个节点都是根节点的孩子，因此每个节点都需要遍历一次，时间复杂度为 `O(n)`，其中 `n` 是树的节点数量。

  ``` c++
  template <class ElemType>
  int Tree<ElemType>::Degree(TreeNode<ElemType> *r) const
  // 求以r为根的树的度
  {
  	TreeNode<ElemType> *p;
  	int d = 0;		   // 根节点的度
  	int maxDegree = 0; // 子树度的最大度
  	for (p = r->firstChild; p != NULL; p = p->nextSibling)
  	{
  		d++;						   // 对孩子个数进行计数
  		int subTreeDegree = Degree(p); //  求以p为根的子树度
  		if (subTreeDegree > maxDegree)
  			maxDegree = subTreeDegree; // 求子树度最大值
  	}
  	if (d > maxDegree)
  		maxDegree = d; // 得到包括根节点的所有节点的最大度
  	return maxDegree;
  }
  
  template <class ElemType>
  int Tree<ElemType>::Degree() const
  // 操作结果： 求树的度
  {
  	return Degree(root);
  }
  
  ```

  

#### 2.2 结果测试

* 双亲法

  ![image-20240316202130179](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240316202130179.png)

  ![image-20240316202252498](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240316202252498.png)

* 先根后根序列

  ![image-20240316201941454](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240316201941454.png)

![image-20240316202004077](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240316202004077.png)

### 3、以高度高的树根为根合并并查集

#### 3.1 定义结点

``` c++
// 并查集元素结点类
template <class ElemType>
struct ElemNode 
{
// 数据成员:
	ElemType data;				// 数据域
	int parent;	                // 双亲域 
};
```



#### 3.2 函数声明

``` c++
template <class ElemType>
class UFSets
{
protected:
// 并查集的数据成员:
	ElemNode<ElemType> *sets;	         // 存储结点的双亲
	int size;					         // 结点个数
// 辅助函数
    int Find(ElemType e) const;		     // 查找元素e所在等价类的根
public:
// 并查集的函数成员:
	UFSets(ElemType es[], int n);	     // 构造sz个单结点树(等价类)
	virtual ~UFSets();				     // 析构函数
	ElemType GetElem(int p)const;        // 根据指定下标取元素值
	int GetOrder(ElemType e)const;       //  取指定元素在数组中的下标
	void Union(ElemType a, ElemType b);	 // 合并a与b所在的等价类 
	void HeightedUnion(ElemType a, ElemType b);// 根据高度合并a与b所在的等价类
	bool Differ(ElemType a, ElemType b); // 判断元素a、b是否在同一个等价类
	UFSets(const UFSets &copy);		     // 复制构造函数
	UFSets &operator =(const UFSets &copy);	// 赋值运算符
};

```



#### 3.3 函数实现

大部分函数为书上原代码。

* 根据高度合并a与b所在的等价类

  具体实现过程如下：

  1. 首先，分别查找元素 `a` 和 `b` 所在等价类的根节点，分别用 `r1` 和 `r2` 表示。
  2. 如果 `r1` 和 `r2` 不相等且至少有一个根节点有效（即不为 `-1`），则执行合并操作。
  3. 首先检查 `r1` 和 `r2` 所在等价类的根节点的父节点数量，即 `sets[r1].parent` 和 `sets[r2].parent`。
  4. 如果两个根节点的父节点数量相同，即两个等价类的高度相同，则将 `r2` 所在等价类的根节点指向 `r1`，同时更新 `r1` 所在等价类的根节点的父节点数量。
  5. 如果两个根节点的父节点数量不同，则将节点数量较少的根节点指向节点数量较多的根节点，以保证合并后的树高度尽可能小。
  6. 在合并操作完成后，即完成了两个等价类的合并。

  ``` c++
  template <class ElemType>
  void UFSets<ElemType>::HeightedUnion(ElemType a, ElemType b)
  // 操作结果：根据结点多少合并a与b所在的等价类
  {
  	int r1 = Find(a); // 查找a所在等价类的根
  	int r2 = Find(b); // 查找b所在等价类的根
  	if (r1 != r2 && r1 != -1)
  	{
  		
  		if (sets[r1].parent == sets[r2].parent) //高度相同
  		{
  			sets[r2].parent = r1;
  			sets[r1].parent--;//高度加一
  		}
  		else
  		{
  			int temp = min(r1, r2); //数值小（高度高）的为根
  			int r =max(r1, r2);  // 高度低的
  			sets[r].parent = temp; // 高度低的指向高度高的
  		}
  	}
  }
  ```

  

